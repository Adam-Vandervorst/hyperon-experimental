[{"func_name": "abs", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "absolute", "signature": {}}, {"func_name": "acos", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "acosh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "adaptive_avg_pool1d", "signature": {}}, {"func_name": "add", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to add to :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "addbmm", "signature": {"batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "input": {"description": "matrix to be added", "type": "Keyword args"}, "alpha": {"description": "multiplier for `batch1 @ batch2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addcdiv", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the numerator tensor", "type": "Args"}, "tensor2": {"description": "the denominator tensor", "type": "Args"}, "value": {"description": "multiplier for :math:`\\text{tensor1} / \\text{tensor2}`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addcmul", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the tensor to be multiplied", "type": "Args"}, "tensor2": {"description": "the tensor to be multiplied", "type": "Args"}, "value": {"description": "multiplier for :math:`tensor1 .* tensor2`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addmm", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "mat1": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addmv", "signature": {"input": {"description": "vector to be added", "type": "Args"}, "mat": {"description": "matrix to be matrix multiplied", "type": "Args"}, "vec": {"description": "vector to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat @ vec` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addr", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "vec1": {"description": "the first vector of the outer product", "type": "Args"}, "vec2": {"description": "the second vector of the outer product", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{vec1} \\otimes \\text{vec2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "adjoint", "signature": {}}, {"func_name": "alias_copy", "signature": {}}, {"func_name": "all", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "allclose", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance. Default: 1e-08", "type": "Args"}, "rtol": {"description": "relative tolerance. Default: 1e-05", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``", "type": "Args"}}}, {"func_name": "amax", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "amin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "aminmax", "signature": {"input": {"description": "", "type": "Args"}, "keepdim": {"description": "", "type": "Args"}}}, {"func_name": "angle", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "any", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "arange", "signature": {"start": {"description": "the starting value for the set of points. Default: ``0``.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points. Default: ``1``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "arccos", "signature": {}}, {"func_name": "arccosh", "signature": {}}, {"func_name": "arcsin", "signature": {}}, {"func_name": "arcsinh", "signature": {}}, {"func_name": "arctan", "signature": {}}, {"func_name": "arctan2", "signature": {}}, {"func_name": "arctanh", "signature": {}}, {"func_name": "argmax", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmax of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not. Ignored if ``dim=None``.", "type": "Args"}}}, {"func_name": "argmin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmin of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not..", "type": "Args"}}}, {"func_name": "argsort", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "controls the relative order of equivalent elements", "type": "Args"}}}, {"func_name": "argwhere", "signature": {}}, {"func_name": "as_strided", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor.", "type": "Args"}}}, {"func_name": "as_strided_copy", "signature": {}}, {"func_name": "as_strided_scatter", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor", "type": "Args"}}}, {"func_name": "as_tensor", "signature": {}}, {"func_name": "asarray", "signature": {"obj": {"description": "a tensor, NumPy array, DLPack Capsule, object that implements Python's", "type": "Args"}, "copy": {"description": "controls whether the returned tensor shares memory with :attr:`obj`.", "type": "Keyword args"}, "requires_grad": {"description": "whether the returned tensor requires grad.", "type": "Keyword args"}}}, {"func_name": "asin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "asinh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "atan", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "atan2", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "atanh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "avg_pool1d", "signature": {}}, {"func_name": "baddbmm", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{batch1} \\mathbin{@} \\text{batch2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bartlett_window", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "bernoulli", "signature": {"input": {"description": "the input tensor of probability values for the Bernoulli distribution", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bilinear", "signature": {}}, {"func_name": "bincount", "signature": {}}, {"func_name": "bitwise_and", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_left_shift", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_not", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_or", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_right_shift", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_xor", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "blackman_window", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "bmm", "signature": {"input": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "mat2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "broadcast_to", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "bucketize", "signature": {"input": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "boundaries": {"description": "1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`input` if provided.", "type": "Keyword args"}}}, {"func_name": "can_cast", "signature": {"from": {"description": "The original :class:`torch.dtype`.", "type": "Args"}, "to": {"description": "The target :class:`torch.dtype`.", "type": "Args"}}}, {"func_name": "cat", "signature": {"tensors": {"description": "any python sequence of tensors of the same type.", "type": "Args"}, "dim": {"description": "the dimension over which the tensors are concatenated", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "ceil", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "channel_shuffle", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}}, {"func_name": "cholesky", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output matrix", "type": "Keyword args"}}}, {"func_name": "cholesky_inverse", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)`,", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output tensor for `inv`", "type": "Keyword args"}}}, {"func_name": "cholesky_solve", "signature": {"input": {"description": "input matrix :math:`b` of size :math:`(*, m, k)`,", "type": "Args"}, "input2": {"description": "input matrix :math:`u` of size :math:`(*, m, m)`,", "type": "Args"}, "upper": {"description": "whether to consider the Cholesky factor as a", "type": "Args"}, "out": {"description": "the output tensor for `c`", "type": "Keyword args"}}}, {"func_name": "chunk", "signature": {}}, {"func_name": "clamp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "min": {"description": "lower-bound of the range to be clamped to", "type": "Args"}, "max": {"description": "upper-bound of the range to be clamped to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "clip", "signature": {}}, {"func_name": "clone", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "col_indices_copy", "signature": {}}, {"func_name": "column_stack", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "combinations", "signature": {}}, {"func_name": "complex", "signature": {"real": {"description": "The real part of the complex tensor. Must be half, float or double.", "type": "Args"}, "imag": {"description": "The imaginary part of the complex tensor. Must be same dtype", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}}, {"func_name": "concat", "signature": {}}, {"func_name": "concatenate", "signature": {}}, {"func_name": "conj", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "conj_physical", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "conv1d", "signature": {}}, {"func_name": "conv2d", "signature": {}}, {"func_name": "conv3d", "signature": {}}, {"func_name": "conv_tbc", "signature": {}}, {"func_name": "conv_transpose1d", "signature": {}}, {"func_name": "conv_transpose2d", "signature": {}}, {"func_name": "conv_transpose3d", "signature": {}}, {"func_name": "copysign", "signature": {"input": {"description": "magnitudes.", "type": "Args"}, "other": {"description": "contains value(s) whose signbit(s) are", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "corrcoef", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}}}, {"func_name": "cos", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cosh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cosine_similarity", "signature": {"x1": {"description": "First input.", "type": "Args"}, "x2": {"description": "Second input.", "type": "Args"}, "dim": {"description": "Dimension along which cosine similarity is computed. Default: 1", "type": "Args"}, "eps": {"description": "Small value to avoid division by zero.", "type": "Args"}}}, {"func_name": "count_nonzero", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dim or tuple of dims along which to count non-zeros.", "type": "Args"}}}, {"func_name": "cov", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Args"}, "fweights": {"description": "A Scalar or 1D tensor of observation vector frequencies representing the number of", "type": "Args"}, "aweights": {"description": "A Scalar or 1D array of observation vector weights.", "type": "Args"}}}, {"func_name": "cross", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "dim ": {"description": "the dimension to take the cross-product in.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "crow_indices_copy", "signature": {}}, {"func_name": "cummax", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim ": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "cummin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim ": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "cumprod", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim ": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cumsum", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim ": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cumulative_trapezoid", "signature": {}}, {"func_name": "deg2rad", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "dequantize", "signature": {"tensor": {"description": "A quantized Tensor", "type": "Args"}}}, {"func_name": "det", "signature": {}}, {"func_name": "detach_copy", "signature": {}}, {"func_name": "diag", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "diag_embed", "signature": {"input": {"description": "the input tensor. Must be at least 1-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diagflat", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "offset": {"description": "the diagonal to consider. Default: 0 (main", "type": "Args"}}}, {"func_name": "diagonal", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diagonal_copy", "signature": {}}, {"func_name": "diagonal_scatter", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "src": {"description": "the tensor to embed into :attr:`input`.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diff", "signature": {"input": {"description": "the tensor to compute the differences on", "type": "Args"}, "n": {"description": "the number of times to recursively compute the difference", "type": "Args"}, "dim": {"description": "the dimension to compute the difference along.", "type": "Args"}, "prepend, append": {"description": "values to prepend or append to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "digamma", "signature": {}}, {"func_name": "dist", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the Right-hand-side input tensor", "type": "Args"}, "p": {"description": "the norm to be computed", "type": "Args"}}}, {"func_name": "div", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "rounding_mode": {"description": "Type of rounding applied to the result:", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "divide", "signature": {}}, {"func_name": "dot", "signature": {"input": {"description": "first tensor in the dot product, must be 1D.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "dsplit", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "dstack", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "empty", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "empty_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "empty_permuted", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "physical_layout": {"description": "the ordering of dimensions physically in memory", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "empty_strided", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the strides of the output tensor", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "eq", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "equal", "signature": {}}, {"func_name": "erf", "signature": {}}, {"func_name": "erfc", "signature": {}}, {"func_name": "erfinv", "signature": {}}, {"func_name": "exp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "exp2", "signature": {}}, {"func_name": "expand_copy", "signature": {}}, {"func_name": "expm1", "signature": {}}, {"func_name": "eye", "signature": {"n": {"description": "the number of rows", "type": "Args"}, "m": {"description": "the number of columns with default being :attr:`n`", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Args"}}}, {"func_name": "fake_quantize_per_channel_affine", "signature": {"input": {"description": "the input value(s), in ``torch.float32``", "type": "Args"}, "scale": {"description": "quantization scale, per channel in ``torch.float32``", "type": "Args"}, "zero_point": {"description": "quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``", "type": "Args"}}}, {"func_name": "fake_quantize_per_tensor_affine", "signature": {"input": {"description": "the input value(s), ``torch.float32`` tensor", "type": "Args"}}}, {"func_name": "fix", "signature": {}}, {"func_name": "flatten", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "start_dim": {"description": "the first dim to flatten", "type": "Args"}, "end_dim": {"description": "the last dim to flatten", "type": "Args"}}}, {"func_name": "flip", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "axis to flip on", "type": "Args"}}}, {"func_name": "fliplr", "signature": {"input": {"description": "Must be at least 2-dimensional.", "type": "Args"}}}, {"func_name": "flipud", "signature": {"input": {"description": "Must be at least 1-dimensional.", "type": "Args"}}}, {"func_name": "float_power", "signature": {"input": {"description": "the base value(s)", "type": "Args"}, "exponent": {"description": "the exponent value(s)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "floor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "floor_divide", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmax", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmod", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "frac", "signature": {}}, {"func_name": "frexp", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "out": {"description": "the output tensors", "type": "Keyword args"}}}, {"func_name": "from_numpy", "signature": {}}, {"func_name": "frombuffer", "signature": {"buffer": {"description": "a Python object that exposes the buffer interface.", "type": "Args"}, "count": {"description": "the number of desired elements to be read.", "type": "Keyword args"}, "offset": {"description": "the number of bytes to skip at the start of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "full", "signature": {"fill_value": {"description": "the value to fill the output tensor with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "full_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "gather", "signature": {"input": {"description": "the source tensor", "type": "Args"}, "dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to gather", "type": "Args"}, "sparse_grad": {"description": "If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.", "type": "Args"}, "out": {"description": "the destination tensor", "type": "Args"}}}, {"func_name": "gcd", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "ge", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "geqrf", "signature": {"input": {"description": "the input matrix", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, Tensor). Ignored if `None`. Default: `None`.", "type": "Keyword args"}}}, {"func_name": "ger", "signature": {}}, {"func_name": "get_default_dtype", "signature": {}}, {"func_name": "get_num_interop_threads", "signature": {}}, {"func_name": "get_num_threads", "signature": {}}, {"func_name": "gradient", "signature": {}}, {"func_name": "greater", "signature": {}}, {"func_name": "greater_equal", "signature": {}}, {"func_name": "gt", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "hamming_window", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "hann_window", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "hardshrink", "signature": {}}, {"func_name": "heaviside", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "values": {"description": "The values to use where :attr:`input` is zero.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "histc", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "bins": {"description": "number of histogram bins", "type": "Args"}, "min": {"description": "lower end of the range (inclusive)", "type": "Args"}, "max": {"description": "upper end of the range (inclusive)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "histogram", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "range": {"description": "Defines the range of the bins.", "type": "Keyword args"}, "weight": {"description": "If provided, weight should have the same shape as input. Each value in", "type": "Keyword args"}, "density": {"description": "If False, the result will contain the count (or total weight) in each bin.", "type": "Keyword args"}, "hist": {"description": "1D Tensor containing the values of the histogram.", "type": "Keyword args"}, "bin_edges": {"description": "1D Tensor containing the edges of the histogram bins.", "type": "Keyword args"}}}, {"func_name": "histogramdd", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "range": {"description": "Defines the leftmost and rightmost bin edges", "type": "Keyword args"}, "weight": {"description": "By default, each value in the input has weight 1. If a weight", "type": "Keyword args"}, "density": {"description": "If False (default), the result will contain the count (or total weight)", "type": "Keyword args"}, "hist": {"description": "N-dimensional Tensor containing the values of the histogram.", "type": "Keyword args"}}}, {"func_name": "hsplit", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "hspmm", "signature": {"mat1": {"description": "the first sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second strided matrix to be matrix multiplied", "type": "Args"}}}, {"func_name": "hstack", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "hypot", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "i0", "signature": {}}, {"func_name": "igamma", "signature": {}}, {"func_name": "igammac", "signature": {}}, {"func_name": "imag", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "index_add", "signature": {}}, {"func_name": "index_copy", "signature": {}}, {"func_name": "index_reduce", "signature": {}}, {"func_name": "index_select", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension in which we index", "type": "Args"}, "index": {"description": "the 1-D tensor containing the indices to index", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "indices_copy", "signature": {}}, {"func_name": "init_num_threads", "signature": {}}, {"func_name": "inner", "signature": {"input": {"description": "First input tensor", "type": "Args"}, "other": {"description": "Second input tensor", "type": "Args"}, "out": {"description": "Optional output tensor to write result into. The output", "type": "Keyword args"}}}, {"func_name": "inverse", "signature": {}}, {"func_name": "is_complex", "signature": {}}, {"func_name": "is_conj", "signature": {}}, {"func_name": "is_floating_point", "signature": {}}, {"func_name": "is_grad_enabled", "signature": {}}, {"func_name": "is_inference", "signature": {}}, {"func_name": "is_inference_mode_enabled", "signature": {}}, {"func_name": "is_nonzero", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "Traceback": {"description": "", "type": "Args"}}}, {"func_name": "isclose", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance. Default: 1e-08", "type": "Args"}, "rtol": {"description": "relative tolerance. Default: 1e-05", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``", "type": "Args"}}}, {"func_name": "isfinite", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "isin", "signature": {"elements": {"description": "Input elements", "type": "Args"}, "test_elements": {"description": "Values against which to test for each input element", "type": "Args"}, "assume_unique": {"description": "If True, assumes both :attr:`elements` and", "type": "Args"}, "invert": {"description": "If True, inverts the boolean return tensor, resulting in True", "type": "Args"}}}, {"func_name": "isinf", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "isnan", "signature": {}}, {"func_name": "isneginf", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "isposinf", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "isreal", "signature": {}}, {"func_name": "istft", "signature": {"input": {"description": "The input tensor. Expected to be in the format of :func:`~torch.stft`,", "type": "Args"}, "n_fft": {"description": "Size of Fourier transform", "type": "Args"}, "center": {"description": "Whether :attr:`input` was padded on both sides so that the :math:`t`-th frame is", "type": "Args"}, "normalized": {"description": "Whether the STFT was normalized. (Default: ``False``)", "type": "Args"}}}, {"func_name": "kaiser_window", "signature": {"window_length": {"description": "length of the window.", "type": "Args"}, "periodic": {"description": "If True, returns a periodic window suitable for use in spectral analysis.", "type": "Args"}, "beta": {"description": "shape parameter for the window.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "kron", "signature": {"out": {"description": "The output tensor. Ignored if ``None``. Default: ``None``", "type": "Keyword args"}}}, {"func_name": "kthvalue", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "k for the k-th smallest element", "type": "Args"}, "dim": {"description": "the dimension to find the kth value along", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor)", "type": "Keyword args"}}}, {"func_name": "lcm", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "ldexp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "a tensor of exponents, typically integers.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "le", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lerp", "signature": {"input": {"description": "the tensor with the starting points", "type": "Args"}, "end": {"description": "the tensor with the ending points", "type": "Args"}, "weight": {"description": "the weight for the interpolation formula", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "less", "signature": {}}, {"func_name": "less_equal", "signature": {}}, {"func_name": "lgamma", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "linspace", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Args"}}}, {"func_name": "log", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log10", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log1p", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log2", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logaddexp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "logaddexp2", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}}}, {"func_name": "logcumsumexp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim ": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logdet", "signature": {}}, {"func_name": "logical_and", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute AND with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_not", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_or", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute OR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_xor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute XOR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logit", "signature": {}}, {"func_name": "logspace", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "base": {"description": "base of the logarithm function. Default: ``10.0``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Args"}}}, {"func_name": "logsumexp", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lt", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lu_solve", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lu_unpack", "signature": {"LU_data": {"description": "the packed LU factorization data", "type": "Args"}, "LU_pivots": {"description": "the packed LU factorization pivots", "type": "Args"}, "unpack_data": {"description": "flag indicating if the data should be unpacked.", "type": "Args"}, "unpack_pivots": {"description": "flag indicating if the pivots should be unpacked into a permutation matrix ``P``.", "type": "Args"}, "out": {"description": "output tuple of three tensors. Ignored if `None`.", "type": "Keyword args"}}}, {"func_name": "masked_select", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "mask ": {"description": "the tensor containing the binary mask to index with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "matmul", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "matrix_exp", "signature": {}}, {"func_name": "matrix_power", "signature": {}}, {"func_name": "max", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not. Default: ``False``.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (max, max_indices)", "type": "Keyword args"}}}, {"func_name": "maximum", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mean", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "median", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "min", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the tuple of two output tensors (min, min_indices)", "type": "Keyword args"}}}, {"func_name": "minimum", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mm", "signature": {"input": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mode", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "moveaxis", "signature": {}}, {"func_name": "movedim", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "source": {"description": "Original positions of the dims to move. These must be unique.", "type": "Args"}, "destination": {"description": "Destination positions for each of the original dims. These must also be unique.", "type": "Args"}}}, {"func_name": "msort", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mul", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "multinomial", "signature": {"input": {"description": "the input tensor containing probabilities", "type": "Args"}, "num_samples": {"description": "number of samples to draw", "type": "Args"}, "replacement": {"description": "whether to draw with replacement or not", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "multiply", "signature": {}}, {"func_name": "mv", "signature": {"input": {"description": "matrix to be multiplied", "type": "Args"}, "vec": {"description": "vector to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mvlgamma", "signature": {}}, {"func_name": "nan_to_num", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "nan": {"description": "the value to replace :literal:`NaN`\\s with. Default is zero.", "type": "Args"}, "posinf": {"description": "if a Number, the value to replace positive infinity values with.", "type": "Args"}, "neginf": {"description": "if a Number, the value to replace negative infinity values with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nanmean", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nanmedian", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "nanquantile", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of quantile values in the range [0, 1]", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "nansum", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "narrow", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}}}, {"func_name": "narrow_copy", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension from. Can", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "native_channel_shuffle", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}}, {"func_name": "ne", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "neg", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "negative", "signature": {}}, {"func_name": "nextafter", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nonzero", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor containing indices", "type": "Keyword args"}}}, {"func_name": "normal", "signature": {"mean": {"description": "the mean for all distributions", "type": "Args"}, "std": {"description": "the standard deviation for all distributions", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "not_equal", "signature": {}}, {"func_name": "numel", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "ones", "signature": {"out": {"description": "the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Args"}}}, {"func_name": "ones_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Args"}}}, {"func_name": "orgqr", "signature": {}}, {"func_name": "ormqr", "signature": {"input": {"description": "tensor of shape `(*, mn, k)` where `*` is zero or more batch dimensions", "type": "Args"}, "tau": {"description": "tensor of shape `(*, min(mn, k))` where `*` is zero or more batch dimensions.", "type": "Args"}, "other": {"description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.", "type": "Args"}, "left": {"description": "controls the order of multiplication.", "type": "Args"}, "transpose": {"description": "controls whether the matrix `Q` is conjugate transposed or not.", "type": "Args"}, "out": {"description": "the output Tensor. Ignored if `None`. Default: `None`.", "type": "Keyword args"}}}, {"func_name": "outer", "signature": {"input": {"description": "1-D input vector", "type": "Args"}, "vec2": {"description": "1-D input vector", "type": "Args"}, "out": {"description": "optional output matrix", "type": "Keyword args"}}}, {"func_name": "pairwise_distance", "signature": {}}, {"func_name": "pdist", "signature": {}}, {"func_name": "permute", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "The desired ordering of dimensions", "type": "Args"}}}, {"func_name": "permute_copy", "signature": {}}, {"func_name": "pinverse", "signature": {}}, {"func_name": "pixel_shuffle", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "upscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}}, {"func_name": "pixel_unshuffle", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "downscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}}, {"func_name": "poisson", "signature": {"input": {"description": "the input tensor containing the rates of the Poisson distribution", "type": "Args"}}}, {"func_name": "polar", "signature": {"abs": {"description": "The absolute value the complex tensor. Must be float or double.", "type": "Args"}, "angle": {"description": "The angle of the complex tensor. Must be same dtype as", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}}, {"func_name": "polygamma", "signature": {}}, {"func_name": "positive", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "pow", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "exponent": {"description": "the exponent tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "self": {"description": "the scalar base value for the power operation", "type": "Args"}}}, {"func_name": "prelu", "signature": {}}, {"func_name": "prod", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "promote_types", "signature": {}}, {"func_name": "qr", "signature": {"input": {"description": "the input tensor of size :math:`(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "Set to ``True`` for reduced QR decomposition and ``False`` for", "type": "Args"}, "out": {"description": "tuple of `Q` and `R` tensors.", "type": "Keyword args"}}}, {"func_name": "quantile", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of values in the range [0, 1].", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "quantize_per_channel", "signature": {}}, {"func_name": "quantize_per_tensor", "signature": {}}, {"func_name": "quantize_per_tensor_dynamic", "signature": {}}, {"func_name": "quantized_batch_norm", "signature": {}}, {"func_name": "quantized_max_pool1d", "signature": {}}, {"func_name": "quantized_max_pool2d", "signature": {}}, {"func_name": "rad2deg", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "rand", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "rand_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "randint", "signature": {"low": {"description": "Lowest integer to be drawn from the distribution. Default: 0.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "size": {"description": "a tuple defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "randint_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "low": {"description": "Lowest integer to be drawn from the distribution. Default: 0.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "randn", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "randn_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "randperm", "signature": {"n": {"description": "the upper bound (exclusive)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "range", "signature": {"start": {"description": "the starting value for the set of points. Default: ``0``.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points. Default: ``1``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "ravel", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "real", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "reciprocal", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "remainder", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "renorm", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "p": {"description": "the power for the norm computation", "type": "Args"}, "dim": {"description": "the dimension to slice over to get the sub-tensors", "type": "Args"}, "maxnorm": {"description": "the maximum norm to keep each sub-tensor under", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "repeat_interleave", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "repeats": {"description": "The number of repetitions for each element.", "type": "Args"}, "dim": {"description": "The dimension along which to repeat values.", "type": "Args"}, "output_size": {"description": "Total output size for the given axis", "type": "Keyword args"}}}, {"func_name": "reshape", "signature": {"input": {"description": "the tensor to be reshaped", "type": "Args"}, "shape": {"description": "the new shape", "type": "Args"}}}, {"func_name": "resolve_conj", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "resolve_neg", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "result_type", "signature": {"tensor1": {"description": "an input tensor or number", "type": "Args"}, "tensor2": {"description": "an input tensor or number", "type": "Args"}}}, {"func_name": "roll", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "shifts": {"description": "The number of places by which the elements", "type": "Args"}, "dims": {"description": "Axis along which to roll", "type": "Args"}}}, {"func_name": "rot90", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "number of times to rotate. Default value is 1", "type": "Args"}, "dims": {"description": "axis to rotate. Default value is [0, 1]", "type": "Args"}}}, {"func_name": "round", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "decimals": {"description": "Number of decimal places to round to (default: 0).", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "row_stack", "signature": {}}, {"func_name": "rsqrt", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "scatter", "signature": {}}, {"func_name": "scatter_add", "signature": {}}, {"func_name": "scatter_reduce", "signature": {}}, {"func_name": "searchsorted", "signature": {"sorted_sequence": {"description": "N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*", "type": "Args"}, "values": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "side": {"description": "the same as :attr:`right` but preferred. \"left\" corresponds to False for :attr:`right`", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`values` if provided.", "type": "Keyword args"}, "sorter": {"description": "if provided, a tensor matching the shape of the unsorted", "type": "Keyword args"}}}, {"func_name": "select", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to slice", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}}, {"func_name": "select_copy", "signature": {}}, {"func_name": "select_scatter", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into.", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}}, {"func_name": "set_flush_denormal", "signature": {"mode": {"description": "Controls whether to enable flush denormal mode or not", "type": "Args"}}}, {"func_name": "set_num_interop_threads", "signature": {}}, {"func_name": "set_num_threads", "signature": {}}, {"func_name": "sgn", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sigmoid", "signature": {}}, {"func_name": "sign", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "signbit", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sin", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sinc", "signature": {}}, {"func_name": "sinh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "slice_copy", "signature": {}}, {"func_name": "slice_scatter", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into", "type": "Args"}, "step": {"description": "the how many elements to skip in", "type": "Args"}}}, {"func_name": "slogdet", "signature": {}}, {"func_name": "smm", "signature": {"input": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}}}, {"func_name": "softmax", "signature": {}}, {"func_name": "sort", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "makes the sorting routine stable, which guarantees that the order", "type": "Args"}, "out": {"description": "the output tuple of (`Tensor`, `LongTensor`) that can", "type": "Keyword args"}}}, {"func_name": "sparse_bsc_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_bsr_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_compressed_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_coo_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}, "is_coalesced": {"description": "When``True``, the caller is", "type": "Keyword args"}}}, {"func_name": "sparse_csc_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_csr_tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "split_copy", "signature": {}}, {"func_name": "split_with_sizes_copy", "signature": {}}, {"func_name": "sqrt", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "square", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "squeeze", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "if given, the input will be squeezed", "type": "Args"}}}, {"func_name": "squeeze_copy", "signature": {}}, {"func_name": "sspaddmm", "signature": {"input": {"description": "a sparse matrix to be added", "type": "Args"}, "mat1": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "a dense matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`mat` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}}}, {"func_name": "stack", "signature": {}}, {"func_name": "std", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "std_mean", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sub", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to subtract from :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "subtract", "signature": {}}, {"func_name": "sum", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "svd", "signature": {"input": {"description": "the input tensor of size `(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "controls whether to compute the reduced or full decomposition, and", "type": "Args"}, "compute_uv": {"description": "controls whether to compute `U` and `V`. Default: `True`.", "type": "Args"}, "out": {"description": "the output tuple of tensors", "type": "Keyword args"}}}, {"func_name": "swapaxes", "signature": {}}, {"func_name": "swapdims", "signature": {}}, {"func_name": "t", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "t_copy", "signature": {}}, {"func_name": "take", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "index": {"description": "the indices into tensor", "type": "Args"}}}, {"func_name": "take_along_dim", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "indices": {"description": "the indices into :attr:`input`. Must have long dtype.", "type": "Args"}, "dim": {"description": "dimension to select along.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tan", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tanh", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tensor", "signature": {"requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "tensor_split", "signature": {"input": {"description": "the tensor to split", "type": "Args"}, "indices_or_sections": {"description": "", "type": "Args"}, "dim": {"description": "dimension along which to split the tensor. Default: ``0``", "type": "Args"}}}, {"func_name": "tile", "signature": {"input": {"description": "the tensor whose elements to repeat.", "type": "Args"}, "dims": {"description": "the number of repetitions per dimension.", "type": "Args"}}}, {"func_name": "topk", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "the k in \"top-k\"", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "largest": {"description": "controls whether to return largest or", "type": "Args"}, "sorted": {"description": "controls whether to return the elements", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor) that can be", "type": "Keyword args"}}}, {"func_name": "trace", "signature": {}}, {"func_name": "transpose", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim0": {"description": "the first dimension to be transposed", "type": "Args"}, "dim1": {"description": "the second dimension to be transposed", "type": "Args"}}}, {"func_name": "transpose_copy", "signature": {}}, {"func_name": "trapezoid", "signature": {}}, {"func_name": "trapz", "signature": {}}, {"func_name": "triangular_solve", "signature": {"b": {"description": "multiple right-hand sides of size :math:`(*, m, k)` where", "type": "Args"}, "A": {"description": "the input triangular coefficient matrix of size :math:`(*, m, m)`", "type": "Args"}, "upper": {"description": "whether :math:`A` is upper or lower triangular. Default: ``True``.", "type": "Args"}, "transpose": {"description": "solves `op(A)X = b` where `op(A) = A^T` if this flag is ``True``,", "type": "Args"}, "unitriangular": {"description": "whether :math:`A` is unit triangular.", "type": "Args"}}}, {"func_name": "tril", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tril_indices", "signature": {}}, {"func_name": "triu", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "triu_indices", "signature": {}}, {"func_name": "true_divide", "signature": {}}, {"func_name": "trunc", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "unbind", "signature": {}}, {"func_name": "unbind_copy", "signature": {}}, {"func_name": "unflatten", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dimension to be unflattened, specified as an index into", "type": "Args"}}}, {"func_name": "unfold_copy", "signature": {}}, {"func_name": "unsafe_chunk", "signature": {}}, {"func_name": "unsafe_split", "signature": {}}, {"func_name": "unsqueeze", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the index at which to insert the singleton dimension", "type": "Args"}}}, {"func_name": "unsqueeze_copy", "signature": {}}, {"func_name": "values_copy", "signature": {}}, {"func_name": "vander", "signature": {}}, {"func_name": "var", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "var_mean", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "vdot", "signature": {"input": {"description": "first tensor in the dot product, must be 1D. Its conjugate is used if it's complex.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}, ".. note:: out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "view_as_complex", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "view_as_complex_copy", "signature": {}}, {"func_name": "view_as_real", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "view_as_real_copy", "signature": {}}, {"func_name": "view_copy", "signature": {}}, {"func_name": "vsplit", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "vstack", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "where", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "xlogy", "signature": {}}, {"func_name": "zeros", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "zeros_like", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}]