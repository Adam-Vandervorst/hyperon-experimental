[{"func_name": "abs", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "acos", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "acosh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "add", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to add to :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "addbmm", "ret_type": "Tensor", "signature": {"batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "input": {"description": "matrix to be added", "type": "Keyword args"}, "alpha": {"description": "multiplier for `batch1 @ batch2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addcdiv", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the numerator tensor", "type": "Args"}, "tensor2": {"description": "the denominator tensor", "type": "Args"}, "value": {"description": "multiplier for :math:`\\text{tensor1} / \\text{tensor2}`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addcmul", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "tensor1": {"description": "the tensor to be multiplied", "type": "Args"}, "tensor2": {"description": "the tensor to be multiplied", "type": "Args"}, "value": {"description": "multiplier for :math:`tensor1 .* tensor2`", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addmm", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "mat1": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addmv", "ret_type": "Tensor", "signature": {"input": {"description": "vector to be added", "type": "Args"}, "mat": {"description": "matrix to be matrix multiplied", "type": "Args"}, "vec": {"description": "vector to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat @ vec` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "addr", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be added", "type": "Args"}, "vec1": {"description": "the first vector of the outer product", "type": "Args"}, "vec2": {"description": "the second vector of the outer product", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{vec1} \\otimes \\text{vec2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "all", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "allclose", "ret_type": "bool", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance. Default: 1e-08", "type": "Args"}, "rtol": {"description": "relative tolerance. Default: 1e-05", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``", "type": "Args"}}}, {"func_name": "amax", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "amin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "aminmax", "ret_type": "(Tensor min, Tensor max)", "signature": {"input": {"description": "", "type": "Args"}, "keepdim": {"description": "", "type": "Args"}}}, {"func_name": "angle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, ">>>": {"description": "3j]))*180/3.14159", "type": "Keyword args"}}}, {"func_name": "any", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "arange", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points. Default: ``0``.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points. Default: ``1``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "argmax", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmax of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not. Ignored if ``dim=None``.", "type": "Args"}}}, {"func_name": "argmin", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce. If ``None``, the argmin of the flattened input is returned.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not..", "type": "Args"}}}, {"func_name": "argsort", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "controls the relative order of equivalent elements", "type": "Args"}}}, {"func_name": "as_strided", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor.", "type": "Args"}}}, {"func_name": "as_strided_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the stride of the output tensor", "type": "Args"}, "storage_offset": {"description": "the offset in the underlying storage of the output tensor", "type": "Args"}}}, {"func_name": "as_tensor", "ret_type": "Tensor", "signature": {"data": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Args"}, "device": {"description": "the device of the constructed tensor. If None and data is a tensor", "type": "Args"}}}, {"func_name": "asarray", "ret_type": "Tensor", "signature": {"obj": {"description": "a tensor, NumPy array, DLPack Capsule, object that implements Python's", "type": "Args"}, "dtype": {"description": "the datatype of the returned tensor.", "type": "Keyword args"}, "copy": {"description": "controls whether the returned tensor shares memory with :attr:`obj`.", "type": "Keyword args"}, "device": {"description": "the device of the returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "whether the returned tensor requires grad.", "type": "Keyword args"}}}, {"func_name": "asin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "asinh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "atan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "atan2", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "atanh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "baddbmm", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be added", "type": "Args"}, "batch1": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "batch2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`input` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`\\text{batch1} \\mathbin{@} \\text{batch2}` (:math:`\\alpha`)", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bartlett_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "bernoulli", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor of probability values for the Bernoulli distribution", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bincount", "ret_type": "Tensor", "signature": {"input": {"description": "1-d int tensor", "type": "Arguments"}, "weights": {"description": "optional, weight for each value in the input tensor.", "type": "Arguments"}, "minlength": {"description": "optional, minimum number of bins. Should be non-negative.", "type": "Arguments"}, "output": {"description": "a tensor of shape ``Size([max(input) + 1])`` if", "type": "Arguments"}}}, {"func_name": "bitwise_and", "ret_type": "Tensor", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_left_shift", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_not", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_or", "ret_type": "Tensor", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_right_shift", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "bitwise_xor", "ret_type": "Tensor", "signature": {"out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "blackman_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "bmm", "ret_type": "Tensor", "signature": {"input": {"description": "the first batch of matrices to be multiplied", "type": "Args"}, "mat2": {"description": "the second batch of matrices to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Args"}}}, {"func_name": "broadcast_to", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "shape": {"description": "the new shape.", "type": "Args"}}}, {"func_name": "bucketize", "ret_type": "Tensor", "signature": {"input": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "boundaries": {"description": "1-D tensor, must contain a strictly increasing sequence, or the return value is undefined.", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`input` if provided.", "type": "Keyword args"}}}, {"func_name": "can_cast", "ret_type": "bool", "signature": {"from": {"description": "The original :class:`torch.dtype`.", "type": "Args"}, "to": {"description": "The target :class:`torch.dtype`.", "type": "Args"}}}, {"func_name": "cat", "ret_type": "Tensor", "signature": {"tensors": {"description": "any python sequence of tensors of the same type.", "type": "Args"}, "dim": {"description": "the dimension over which the tensors are concatenated", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "ceil", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "channel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}}, {"func_name": "cholesky", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output matrix", "type": "Keyword args"}}}, {"func_name": "cholesky_inverse", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor :math:`A` of size :math:`(*, n, n)`,", "type": "Args"}, "upper": {"description": "flag that indicates whether to return a", "type": "Args"}, "out": {"description": "the output tensor for `inv`", "type": "Keyword args"}}}, {"func_name": "cholesky_solve", "ret_type": "Tensor", "signature": {"input": {"description": "input matrix :math:`b` of size :math:`(*, m, k)`,", "type": "Args"}, "input2": {"description": "input matrix :math:`u` of size :math:`(*, m, m)`,", "type": "Args"}, "upper": {"description": "whether to consider the Cholesky factor as a", "type": "Args"}, "out": {"description": "the output tensor for `c`", "type": "Keyword args"}}}, {"func_name": "chunk", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor to split", "type": "Arguments"}, "chunks": {"description": "number of chunks to return", "type": "Arguments"}, "dim": {"description": "dimension along which to split the tensor", "type": "Arguments"}}}, {"func_name": "clamp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "min": {"description": "lower-bound of the range to be clamped to", "type": "Args"}, "max": {"description": "upper-bound of the range to be clamped to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "clone", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "column_stack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "combinations", "ret_type": "seq", "signature": {"input": {"description": "1D vector.", "type": "Arguments"}, "r": {"description": "number of elements to combine", "type": "Arguments"}, "with_replacement": {"description": "whether to allow duplication in combination", "type": "Arguments"}}}, {"func_name": "complex", "ret_type": "Tensor", "signature": {"real": {"description": "The real part of the complex tensor. Must be half, float or double.", "type": "Args"}, "imag": {"description": "The imaginary part of the complex tensor. Must be same dtype", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}}, {"func_name": "conj", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, ">>>": {"description": "3j])", "type": "Args"}}}, {"func_name": "conj_physical", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, ">>>": {"description": "3j]))", "type": "Keyword args"}}}, {"func_name": "copysign", "ret_type": "Tensor", "signature": {"input": {"description": "magnitudes.", "type": "Args"}, "other": {"description": "contains value(s) whose signbit(s) are", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "corrcoef", "ret_type": "Tensor", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}}}, {"func_name": "cos", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cosh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cosine_similarity", "ret_type": "Tensor", "signature": {"x1": {"description": "First input.", "type": "Args"}, "x2": {"description": "Second input.", "type": "Args"}, "dim": {"description": "Dimension along which cosine similarity is computed. Default: 1", "type": "Args"}, "eps": {"description": "Small value to avoid division by zero.", "type": "Args"}}}, {"func_name": "count_nonzero", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dim or tuple of dims along which to count non-zeros.", "type": "Args"}}}, {"func_name": "cov", "ret_type": "Tensor", "signature": {"input": {"description": "A 2D matrix containing multiple variables and observations, or a", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Args"}, "fweights": {"description": "A Scalar or 1D tensor of observation vector frequencies representing the number of", "type": "Args"}, "aweights": {"description": "A Scalar or 1D array of observation vector weights.", "type": "Args"}}}, {"func_name": "cross", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "dim": {"description": "the dimension to take the cross-product in.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cummax", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "cummin", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "cumprod", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cumsum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "cumulative_trapezoid", "ret_type": "Tensor", "signature": {"y": {"description": "Values to use when computing the trapezoidal rule.", "type": "Arguments"}, "x": {"description": "If specified, defines spacing between values as specified above.", "type": "Arguments"}, "dx": {"description": "constant spacing between values. If neither :attr:`x` or :attr:`dx`", "type": "Keyword arguments"}, "dim": {"description": "The dimension along which to compute the trapezoidal rule.", "type": "Keyword arguments"}, ">>>": {"description": "1) * (1 + 5)) / 2", "type": "Keyword arguments"}}}, {"func_name": "deg2rad", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "dequantize", "ret_type": "Tensor", "signature": {"tensor": {"description": "A quantized Tensor", "type": "Args"}}}, {"func_name": "diag", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "diag_embed", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 1-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diagflat", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "offset": {"description": "the diagonal to consider. Default: 0 (main", "type": "Args"}}}, {"func_name": "diagonal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diagonal_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor. Must be at least 2-dimensional.", "type": "Args"}, "src": {"description": "the tensor to embed into :attr:`input`.", "type": "Args"}, "offset": {"description": "which diagonal to consider. Default: 0", "type": "Args"}, "dim1": {"description": "first dimension with respect to which to", "type": "Args"}, "dim2": {"description": "second dimension with respect to which to", "type": "Args"}}}, {"func_name": "diff", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compute the differences on", "type": "Args"}, "n": {"description": "the number of times to recursively compute the difference", "type": "Args"}, "dim": {"description": "the dimension to compute the difference along.", "type": "Args"}, "prepend,": {"description": "values to prepend or append to", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "dist", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the Right-hand-side input tensor", "type": "Args"}, "p": {"description": "the norm to be computed", "type": "Args"}}}, {"func_name": "div", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "rounding_mode": {"description": "Type of rounding applied to the result:", "type": "Keyword args"}, "*": {"description": "rounds the results of the division down.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "dot", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor in the dot product, must be 1D.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "dsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "dstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "empty", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "empty_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "empty_permuted", "ret_type": "Tensor", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "physical_layout": {"description": "the ordering of dimensions physically in memory", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "empty_strided", "ret_type": "Tensor", "signature": {"size": {"description": "the shape of the output tensor", "type": "Args"}, "stride": {"description": "the strides of the output tensor", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "eq", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "exp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "eye", "ret_type": "Tensor", "signature": {"n": {"description": "the number of rows", "type": "Args"}, "m": {"description": "the number of columns with default being :attr:`n`", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}}, {"func_name": "fake_quantize_per_channel_affine", "ret_type": "Tensor", "signature": {"input": {"description": "the input value(s), in ``torch.float32``", "type": "Args"}, "scale": {"description": "quantization scale, per channel in ``torch.float32``", "type": "Args"}, "zero_point": {"description": "quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``", "type": "Args"}}}, {"func_name": "fake_quantize_per_tensor_affine", "ret_type": "Tensor", "signature": {"input": {"description": "the input value(s), ``torch.float32`` tensor", "type": "Args"}}}, {"func_name": "flatten", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "start_dim": {"description": "the first dim to flatten", "type": "Args"}, "end_dim": {"description": "the last dim to flatten", "type": "Args"}}}, {"func_name": "flip", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "axis to flip on", "type": "Args"}}}, {"func_name": "fliplr", "ret_type": "Tensor", "signature": {"input": {"description": "Must be at least 2-dimensional.", "type": "Args"}}}, {"func_name": "flipud", "ret_type": "Tensor", "signature": {"input": {"description": "Must be at least 1-dimensional.", "type": "Args"}}}, {"func_name": "float_power", "ret_type": "Tensor", "signature": {"input": {"description": "the base value(s)", "type": "Args"}, "exponent": {"description": "the exponent value(s)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "floor", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "floor_divide", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmax", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "fmod", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "frexp", "ret_type": "(Tensor mantissa, Tensor exponent)", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "out": {"description": "the output tensors", "type": "Keyword args"}}}, {"func_name": "frombuffer", "ret_type": "Tensor", "signature": {"buffer": {"description": "a Python object that exposes the buffer interface.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "count": {"description": "the number of desired elements to be read.", "type": "Keyword args"}, "offset": {"description": "the number of bytes to skip at the start of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "full", "ret_type": "Tensor", "signature": {"size": {"description": "a list, tuple, or :class:`torch.Size` of integers defining the", "type": "Args"}, "fill_value": {"description": "the value to fill the output tensor with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "full_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "gather", "ret_type": "Tensor", "signature": {"input": {"description": "the source tensor", "type": "Args"}, "dim": {"description": "the axis along which to index", "type": "Args"}, "index": {"description": "the indices of elements to gather", "type": "Args"}, "sparse_grad": {"description": "If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.", "type": "Keyword arguments"}, "out": {"description": "the destination tensor", "type": "Keyword arguments"}}}, {"func_name": "gcd", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "ge", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "geqrf", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input matrix", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, Tensor). Ignored if `None`. Default: `None`.", "type": "Keyword args"}}}, {"func_name": "gradient", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor that represents the values of the function", "type": "Args"}, "spacing": {"description": ":attr:`spacing` can be used to modify", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to approximate the gradient over.  By default", "type": "Keyword args"}, "edge_order": {"description": "1 or 2, for `first-order", "type": "Keyword args"}}}, {"func_name": "gt", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "hamming_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "alpha": {"description": "The coefficient :math:`\\alpha` in the equation above", "type": "Arguments"}, "beta": {"description": "The coefficient :math:`\\beta` in the equation above", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "hann_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "the size of returned window", "type": "Arguments"}, "periodic": {"description": "If True, returns a window to be used as periodic", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "heaviside", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "values": {"description": "The values to use where :attr:`input` is zero.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "histc", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "bins": {"description": "number of histogram bins", "type": "Args"}, "min": {"description": "lower end of the range (inclusive)", "type": "Args"}, "max": {"description": "upper end of the range (inclusive)", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "histogram", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "range": {"description": "Defines the range of the bins.", "type": "Keyword args"}, "weight": {"description": "If provided, weight should have the same shape as input. Each value in", "type": "Keyword args"}, "density": {"description": "If False, the result will contain the count (or total weight) in each bin.", "type": "Keyword args"}, "hist": {"description": "1D Tensor containing the values of the histogram.", "type": "Keyword args"}, "bin_edges": {"description": "1D Tensor containing the edges of the histogram bins.", "type": "Keyword args"}}}, {"func_name": "histogramdd", "ret_type": "(Tensor, Tensor[])", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "range": {"description": "Defines the leftmost and rightmost bin edges", "type": "Keyword args"}, "weight": {"description": "By default, each value in the input has weight 1. If a weight", "type": "Keyword args"}, "density": {"description": "If False (default), the result will contain the count (or total weight)", "type": "Keyword args"}, "hist": {"description": "N-dimensional Tensor containing the values of the histogram.", "type": "Keyword args"}}}, {"func_name": "hsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "hspmm", "ret_type": "Tensor", "signature": {"mat1": {"description": "the first sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second strided matrix to be matrix multiplied", "type": "Args"}}}, {"func_name": "hstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "hypot", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "imag", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "index_select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension in which we index", "type": "Args"}, "index": {"description": "the 1-D tensor containing the indices to index", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "inner", "ret_type": "Tensor", "signature": {"input": {"description": "First input tensor", "type": "Args"}, "other": {"description": "Second input tensor", "type": "Args"}, "out": {"description": "Optional output tensor to write result into. The output", "type": "Keyword args"}}}, {"func_name": "is_nonzero", "ret_type": "(bool)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "Traceback": {"description": "", "type": "Args"}}}, {"func_name": "isclose", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor to compare", "type": "Args"}, "other": {"description": "second tensor to compare", "type": "Args"}, "atol": {"description": "absolute tolerance. Default: 1e-08", "type": "Args"}, "rtol": {"description": "relative tolerance. Default: 1e-05", "type": "Args"}, "equal_nan": {"description": "if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``", "type": "Args"}}}, {"func_name": "isfinite", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "isin", "ret_type": "Tensor", "signature": {"elements": {"description": "Input elements", "type": "Args"}, "test_elements": {"description": "Values against which to test for each input element", "type": "Args"}, "assume_unique": {"description": "If True, assumes both :attr:`elements` and", "type": "Args"}, "invert": {"description": "If True, inverts the boolean return tensor, resulting in True", "type": "Args"}}}, {"func_name": "isinf", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "isnan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Arguments"}}}, {"func_name": "isneginf", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "isposinf", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "isreal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Arguments"}}}, {"func_name": "istft", "ret_type": "Tensor:", "signature": {"input": {"description": "The input tensor. Expected to be in the format of :func:`~torch.stft`,", "type": "Args"}, "or": {"description": "n_fft) // hop_length` otherwise.", "type": "Args"}, "n_fft": {"description": "Size of Fourier transform", "type": "Args"}, "center": {"description": "Whether :attr:`input` was padded on both sides so that the :math:`t`-th frame is", "type": "Args"}, "normalized": {"description": "Whether the STFT was normalized. (Default: ``False``)", "type": "Args"}, "original": {"description": "1) * hop_length` for", "type": "Args"}, "centered": {"description": "1) * hop_length` otherwise, where `T`", "type": "Args"}}}, {"func_name": "kaiser_window", "ret_type": "Tensor", "signature": {"window_length": {"description": "length of the window.", "type": "Args"}, "periodic": {"description": "If True, returns a periodic window suitable for use in spectral analysis.", "type": "Args"}, "beta": {"description": "shape parameter for the window.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned window tensor. Only", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "kron", "ret_type": "Tensor", "signature": {"out": {"description": "The output tensor. Ignored if ``None``. Default: ``None``", "type": "Keyword args"}}}, {"func_name": "kthvalue", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "k for the k-th smallest element", "type": "Args"}, "dim": {"description": "the dimension to find the kth value along", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor)", "type": "Keyword args"}}}, {"func_name": "lcm", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "ldexp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "a tensor of exponents, typically integers.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "le", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lerp", "ret_type": null, "signature": {"input": {"description": "the tensor with the starting points", "type": "Args"}, "end": {"description": "the tensor with the ending points", "type": "Args"}, "weight": {"description": "the weight for the interpolation formula", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lgamma", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "linspace", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the data type to perform the computation in.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}}, {"func_name": "log", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log10", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log1p", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "log2", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logaddexp", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "logaddexp2", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}}}, {"func_name": "logcumsumexp", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to do the operation over", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logdet", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor of size ``(*, n, n)`` where ``*`` is zero or more", "type": "Arguments"}}}, {"func_name": "logical_and", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute AND with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_not", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_or", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute OR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logical_xor", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor to compute XOR with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "logspace", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "steps": {"description": "size of the constructed tensor", "type": "Args"}, "base": {"description": "base of the logarithm function. Default: ``10.0``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the data type to perform the computation in.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}}, {"func_name": "logsumexp", "ret_type": null, "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lt", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lu_solve", "ret_type": "Tensor", "signature": {"b": {"description": "the RHS tensor of size :math:`(*, m, k)`, where :math:`*`", "type": "Arguments"}, "LU_data": {"description": "the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,", "type": "Arguments"}, "LU_pivots": {"description": "the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "lu_unpack", "ret_type": "(Tensor, Tensor, Tensor)", "signature": {"LU_data": {"description": "the packed LU factorization data", "type": "Args"}, "LU_pivots": {"description": "the packed LU factorization pivots", "type": "Args"}, "unpack_data": {"description": "flag indicating if the data should be unpacked.", "type": "Args"}, "unpack_pivots": {"description": "flag indicating if the pivots should be unpacked into a permutation matrix ``P``.", "type": "Args"}, "out": {"description": "output tuple of three tensors. Ignored if `None`.", "type": "Keyword args"}}}, {"func_name": "masked_select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "mask": {"description": "the tensor containing the binary mask to index with", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "matmul", "ret_type": "Tensor", "signature": {"input": {"description": "the first tensor to be multiplied", "type": "Arguments"}, "other": {"description": "the second tensor to be multiplied", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "max", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not. Default: ``False``.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (max, max_indices)", "type": "Keyword args"}}}, {"func_name": "maximum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mean", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "median", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "min", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the tuple of two output tensors (min, min_indices)", "type": "Keyword args"}}}, {"func_name": "minimum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mm", "ret_type": "Tensor", "signature": {"input": {"description": "the first matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "the second matrix to be matrix multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mode", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "out": {"description": "the result tuple of two output tensors (values, indices)", "type": "Keyword args"}}}, {"func_name": "movedim", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "source": {"description": "Original positions of the dims to move. These must be unique.", "type": "Args"}, "destination": {"description": "Destination positions for each of the original dims. These must also be unique.", "type": "Args"}}}, {"func_name": "msort", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mul", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to multiply input by.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "multinomial", "ret_type": "LongTensor", "signature": {"input": {"description": "the input tensor containing probabilities", "type": "Args"}, "num_samples": {"description": "number of samples to draw", "type": "Args"}, "replacement": {"description": "whether to draw with replacement or not", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "mv", "ret_type": "Tensor", "signature": {"input": {"description": "matrix to be multiplied", "type": "Args"}, "vec": {"description": "vector to be multiplied", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nan_to_num", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "nan": {"description": "the value to replace :literal:`NaN`\\s with. Default is zero.", "type": "Args"}, "posinf": {"description": "if a Number, the value to replace positive infinity values with.", "type": "Args"}, "neginf": {"description": "if a Number, the value to replace negative infinity values with.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nanmean", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nanmedian", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "nanquantile", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of quantile values in the range [0, 1]", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "nansum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "narrow", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}}}, {"func_name": "narrow_copy", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to narrow", "type": "Args"}, "dim": {"description": "the dimension along which to narrow", "type": "Args"}, "start": {"description": "index of the element to start the narrowed dimension from. Can", "type": "Args"}, "length": {"description": "length of the narrowed dimension, must be weakly positive", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "native_channel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "groups": {"description": "number of groups to divide channels in and rearrange.", "type": "Args"}}}, {"func_name": "ne", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to compare", "type": "Args"}, "other": {"description": "the tensor or value to compare", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "neg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "nextafter", "ret_type": "Tensor", "signature": {"input": {"description": "the first input tensor", "type": "Args"}, "other": {"description": "the second input tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, ">>>": {"description": "eps])", "type": "Keyword args"}}}, {"func_name": "nonzero", "ret_type": "LongTensor or tuple of LongTensors", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor containing indices", "type": "Keyword args"}}}, {"func_name": "normal", "ret_type": "Tensor", "signature": {"mean": {"description": "the mean for all distributions", "type": "Args"}, "std": {"description": "the standard deviation for all distributions", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}}}, {"func_name": "numel", "ret_type": "int", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "ones", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}}}, {"func_name": "ones_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword arguments"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword arguments"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword arguments"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword arguments"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword arguments"}}}, {"func_name": "ormqr", "ret_type": "Tensor", "signature": {"input": {"description": "tensor of shape `(*, mn, k)` where `*` is zero or more batch dimensions", "type": "Args"}, "tau": {"description": "tensor of shape `(*, min(mn, k))` where `*` is zero or more batch dimensions.", "type": "Args"}, "other": {"description": "tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.", "type": "Args"}, "left": {"description": "controls the order of multiplication.", "type": "Args"}, "transpose": {"description": "controls whether the matrix `Q` is conjugate transposed or not.", "type": "Args"}, "out": {"description": "the output Tensor. Ignored if `None`. Default: `None`.", "type": "Keyword args"}}}, {"func_name": "outer", "ret_type": "Tensor", "signature": {"input": {"description": "1-D input vector", "type": "Args"}, "vec2": {"description": "1-D input vector", "type": "Args"}, "out": {"description": "optional output matrix", "type": "Keyword args"}}}, {"func_name": "permute", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dims": {"description": "The desired ordering of dimensions", "type": "Args"}}}, {"func_name": "pixel_shuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "upscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}}, {"func_name": "pixel_unshuffle", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor", "type": "Args"}, "downscale_factor": {"description": "factor to increase spatial resolution by", "type": "Args"}}}, {"func_name": "poisson", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor containing the rates of the Poisson distribution", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}}}, {"func_name": "polar", "ret_type": "Tensor", "signature": {"abs": {"description": "The absolute value the complex tensor. Must be float or double.", "type": "Args"}, "angle": {"description": "The angle of the complex tensor. Must be same dtype as", "type": "Args"}, "out": {"description": "If the inputs are ``torch.float32``, must be", "type": "Keyword args"}}}, {"func_name": "positive", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "pow", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "exponent": {"description": "the exponent tensor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "self": {"description": "the scalar base value for the power operation", "type": "Args"}}}, {"func_name": "prod", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "qr", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor of size :math:`(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "Set to ``True`` for reduced QR decomposition and ``False`` for", "type": "Args"}, "out": {"description": "tuple of `Q` and `R` tensors.", "type": "Keyword args"}}}, {"func_name": "quantile", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "q": {"description": "a scalar or 1D tensor of values in the range [0, 1].", "type": "Args"}, "dim": {"description": "the dimension to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}, "interpolation": {"description": "interpolation method to use when the desired quantile lies between two data points.", "type": "Keyword arguments"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "quantize_per_channel", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor to quantize", "type": "Arguments"}, "scales": {"description": "float 1D tensor of scales to use, size should match ``input.size(axis)``", "type": "Arguments"}, "zero_points": {"description": "integer 1D tensor of offset to use, size should match ``input.size(axis)``", "type": "Arguments"}, "axis": {"description": "dimension on which apply per-channel quantization", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}}}, {"func_name": "quantize_per_tensor", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor or list of tensors to quantize", "type": "Arguments"}, "scale": {"description": "scale to apply in quantization formula", "type": "Arguments"}, "zero_point": {"description": "offset in integer value that maps to float zero", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}}}, {"func_name": "quantize_per_tensor_dynamic", "ret_type": "Tensor", "signature": {"input": {"description": "float tensor or list of tensors to quantize", "type": "Arguments"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Arguments"}, "reduce_range": {"description": "a flag to indicate whether to reduce the range of quantized", "type": "Arguments"}}}, {"func_name": "quantized_batch_norm", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "weight": {"description": "float tensor that corresponds to the gamma, size C", "type": "Arguments"}, "bias": {"description": "float tensor that corresponds to the beta, size C", "type": "Arguments"}, "mean": {"description": "float mean value in batch normalization, size C", "type": "Arguments"}, "var": {"description": "float tensor for variance, size C", "type": "Arguments"}, "eps": {"description": "a value added to the denominator for numerical stability.", "type": "Arguments"}, "output_scale": {"description": "output quantized tensor scale", "type": "Arguments"}, "output_zero_point": {"description": "output quantized tensor zero_point", "type": "Arguments"}}}, {"func_name": "quantized_max_pool1d", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "kernel_size": {"description": "the size of the sliding window", "type": "Arguments"}, "stride": {"description": "the stride of the sliding window", "type": "Arguments"}, "padding": {"description": "padding to be added on both sides, must be >= 0 and <= kernel_size / 2", "type": "Arguments"}, "dilation": {"description": "The stride between elements within a sliding window, must be > 0. Default 1", "type": "Arguments"}, "ceil_mode": {"description": "If True, will use ceil instead of floor to compute the output shape.", "type": "Arguments"}}}, {"func_name": "quantized_max_pool2d", "ret_type": "Tensor", "signature": {"input": {"description": "quantized tensor", "type": "Arguments"}, "kernel_size": {"description": "the size of the sliding window", "type": "Arguments"}, "stride": {"description": "the stride of the sliding window", "type": "Arguments"}, "padding": {"description": "padding to be added on both sides, must be >= 0 and <= kernel_size / 2", "type": "Arguments"}, "dilation": {"description": "The stride between elements within a sliding window, must be > 0. Default 1", "type": "Arguments"}, "ceil_mode": {"description": "If True, will use ceil instead of floor to compute the output shape.", "type": "Arguments"}}}, {"func_name": "rad2deg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword arguments"}}}, {"func_name": "rand", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "rand_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "randint", "ret_type": "Tensor", "signature": {"low": {"description": "Lowest integer to be drawn from the distribution. Default: 0.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "size": {"description": "a tuple defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor. Default: if ``None``,", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "randint_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "low": {"description": "Lowest integer to be drawn from the distribution. Default: 0.", "type": "Args"}, "high": {"description": "One above the highest integer to be drawn from the distribution.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "randn", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "randn_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}, {"func_name": "randperm", "ret_type": "Tensor", "signature": {"n": {"description": "the upper bound (exclusive)", "type": "Args"}, "generator": {"description": "a pseudorandom number generator for sampling", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "range", "ret_type": "Tensor", "signature": {"start": {"description": "the starting value for the set of points. Default: ``0``.", "type": "Args"}, "end": {"description": "the ending value for the set of points", "type": "Args"}, "step": {"description": "the gap between each pair of adjacent points. Default: ``1``.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "ravel", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "real", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "reciprocal", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "remainder", "ret_type": "Tensor", "signature": {"input": {"description": "the dividend", "type": "Args"}, "other": {"description": "the divisor", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "renorm", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "p": {"description": "the power for the norm computation", "type": "Args"}, "dim": {"description": "the dimension to slice over to get the sub-tensors", "type": "Args"}, "maxnorm": {"description": "the maximum norm to keep each sub-tensor under", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "repeat_interleave", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "repeats": {"description": "The number of repetitions for each element.", "type": "Args"}, "dim": {"description": "The dimension along which to repeat values.", "type": "Args"}, "output_size": {"description": "Total output size for the given axis", "type": "Keyword args"}}}, {"func_name": "reshape", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor to be reshaped", "type": "Args"}, "shape": {"description": "the new shape", "type": "Args"}}}, {"func_name": "resolve_conj", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, ">>>": {"description": "3j])", "type": "Args"}}}, {"func_name": "resolve_neg", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, ">>>": {"description": "3j])", "type": "Args"}}}, {"func_name": "result_type", "ret_type": "dtype", "signature": {"tensor1": {"description": "an input tensor or number", "type": "Args"}, "tensor2": {"description": "an input tensor or number", "type": "Args"}}}, {"func_name": "roll", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "shifts": {"description": "The number of places by which the elements", "type": "Args"}, "dims": {"description": "Axis along which to roll", "type": "Args"}}}, {"func_name": "rot90", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "number of times to rotate. Default value is 1", "type": "Args"}, "dims": {"description": "axis to rotate. Default value is [0, 1]", "type": "Args"}}}, {"func_name": "round", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "decimals": {"description": "Number of decimal places to round to (default: 0).", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "rsqrt", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "searchsorted", "ret_type": "Tensor", "signature": {"sorted_sequence": {"description": "N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*", "type": "Args"}, "values": {"description": "N-D tensor or a Scalar containing the search value(s).", "type": "Args"}, "out_int32": {"description": "indicate the output data type. torch.int32 if True, torch.int64 otherwise.", "type": "Keyword args"}, "right": {"description": "if False, return the first suitable location that is found. If True, return the", "type": "Keyword args"}, "side": {"description": "the same as :attr:`right` but preferred. \"left\" corresponds to False for :attr:`right`", "type": "Keyword args"}, "out": {"description": "the output tensor, must be the same size as :attr:`values` if provided.", "type": "Keyword args"}, "sorter": {"description": "if provided, a tensor matching the shape of the unsorted", "type": "Keyword args"}}}, {"func_name": "select", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to slice", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}}, {"func_name": "select_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into.", "type": "Args"}, "index": {"description": "the index to select with", "type": "Args"}}}, {"func_name": "set_flush_denormal", "ret_type": "bool", "signature": {"mode": {"description": "Controls whether to enable flush denormal mode or not", "type": "Args"}}}, {"func_name": "sgn", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sign", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "signbit", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sin", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sinh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "slice_scatter", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "src": {"description": "The tensor to embed into :attr:`input`", "type": "Args"}, "dim": {"description": "the dimension to insert the slice into", "type": "Args"}, "step": {"description": "the how many elements to skip in", "type": "Args"}}}, {"func_name": "smm", "ret_type": "Tensor", "signature": {"input": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}}}, {"func_name": "sort", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "descending": {"description": "controls the sorting order (ascending or descending)", "type": "Args"}, "stable": {"description": "makes the sorting routine stable, which guarantees that the order", "type": "Args"}, "out": {"description": "the output tuple of (`Tensor`, `LongTensor`) that can", "type": "Keyword args"}}}, {"func_name": "sparse_bsc_tensor", "ret_type": "Tensor", "signature": {"ccol_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "row_indices": {"description": "Row block co-ordinates of each block in", "type": "Args"}, "values": {"description": "Initial blocks for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_bsr_tensor", "ret_type": "Tensor", "signature": {"crow_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "col_indices": {"description": "Column block co-ordinates of each block", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_compressed_tensor", "ret_type": "Tensor", "signature": {"compressed_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "plain_indices": {"description": "Plain dimension (column or row)", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "layout": {"description": "the desired layout of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_coo_tensor", "ret_type": "Tensor", "signature": {"indices": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list, tuple,", "type": "Args"}, "size": {"description": "Size of the sparse tensor. If not", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}, "is_coalesced": {"description": "When``True``, the caller is", "type": "Keyword args"}}}, {"func_name": "sparse_csc_tensor", "ret_type": "Tensor", "signature": {"ccol_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "row_indices": {"description": "Row co-ordinates of each element in", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sparse_csr_tensor", "ret_type": "Tensor", "signature": {"crow_indices": {"description": "(B+1)-dimensional array of size", "type": "Args"}, "col_indices": {"description": "Column co-ordinates of each element in", "type": "Args"}, "values": {"description": "Initial values for the tensor. Can be a list,", "type": "Args"}, "size": {"description": "Size of the", "type": "Args"}, "dtype": {"description": "the desired data type of", "type": "Keyword args"}, "device": {"description": "the desired device of", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "check_invariants": {"description": "If sparse tensor invariants are checked.", "type": "Keyword args"}}}, {"func_name": "sqrt", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "square", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "squeeze", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "if given, the input will be squeezed", "type": "Args"}}}, {"func_name": "sspaddmm", "ret_type": "Tensor", "signature": {"input": {"description": "a sparse matrix to be added", "type": "Args"}, "mat1": {"description": "a sparse matrix to be matrix multiplied", "type": "Args"}, "mat2": {"description": "a dense matrix to be matrix multiplied", "type": "Args"}, "beta": {"description": "multiplier for :attr:`mat` (:math:`\\beta`)", "type": "Keyword args"}, "alpha": {"description": "multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)", "type": "Keyword args"}}}, {"func_name": "stack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Arguments"}, "dim": {"description": "dimension to insert. Has to be between 0 and the number", "type": "Arguments"}}}, {"func_name": "std", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "std_mean", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sub", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "other": {"description": "the tensor or number to subtract from :attr:`input`.", "type": "Args"}, "alpha": {"description": "the multiplier for :attr:`other`.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "sum", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Args"}}}, {"func_name": "svd", "ret_type": "(Tensor, Tensor, Tensor)", "signature": {"input": {"description": "the input tensor of size `(*, m, n)` where `*` is zero or more", "type": "Args"}, "some": {"description": "controls whether to compute the reduced or full decomposition, and", "type": "Args"}, "compute_uv": {"description": "controls whether to compute `U` and `V`. Default: `True`.", "type": "Args"}, "out": {"description": "the output tuple of tensors", "type": "Keyword args"}}}, {"func_name": "t", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "take", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "index": {"description": "the indices into tensor", "type": "Args"}}}, {"func_name": "take_along_dim", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "indices": {"description": "the indices into :attr:`input`. Must have long dtype.", "type": "Args"}, "dim": {"description": "dimension to select along.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tan", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tanh", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tensor", "ret_type": "Tensor", "signature": {"data": {"description": "Initial data for the tensor. Can be a list, tuple,", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the device of the constructed tensor. If None and data is a tensor", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "pin_memory": {"description": "If set, returned tensor would be allocated in", "type": "Keyword args"}}}, {"func_name": "tensor_split", "ret_type": "List of Tensors", "signature": {"input": {"description": "the tensor to split", "type": "Args"}, "indices_or_sections": {"description": "", "type": "Args"}, "dim": {"description": "dimension along which to split the tensor. Default: ``0``", "type": "Args"}}}, {"func_name": "tile", "ret_type": "Tensor", "signature": {"input": {"description": "the tensor whose elements to repeat.", "type": "Args"}, "dims": {"description": "the number of repetitions per dimension.", "type": "Args"}}}, {"func_name": "topk", "ret_type": "(Tensor, LongTensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "k": {"description": "the k in \"top-k\"", "type": "Args"}, "dim": {"description": "the dimension to sort along", "type": "Args"}, "largest": {"description": "controls whether to return largest or", "type": "Args"}, "sorted": {"description": "controls whether to return the elements", "type": "Args"}, "out": {"description": "the output tuple of (Tensor, LongTensor) that can be", "type": "Keyword args"}}}, {"func_name": "transpose", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim0": {"description": "the first dimension to be transposed", "type": "Args"}, "dim1": {"description": "the second dimension to be transposed", "type": "Args"}}}, {"func_name": "trapezoid", "ret_type": "Tensor", "signature": {"y": {"description": "Values to use when computing the trapezoidal rule.", "type": "Arguments"}, "x": {"description": "If specified, defines spacing between values as specified above.", "type": "Arguments"}, "dx": {"description": "constant spacing between values. If neither :attr:`x` or :attr:`dx`", "type": "Keyword arguments"}, "dim": {"description": "The dimension along which to compute the trapezoidal rule.", "type": "Keyword arguments"}}}, {"func_name": "triangular_solve", "ret_type": "(Tensor, Tensor)", "signature": {"b": {"description": "multiple right-hand sides of size :math:`(*, m, k)` where", "type": "Args"}, "A": {"description": "the input triangular coefficient matrix of size :math:`(*, m, m)`", "type": "Args"}, "upper": {"description": "whether :math:`A` is upper or lower triangular. Default: ``True``.", "type": "Args"}, "transpose": {"description": "solves `op(A)X = b` where `op(A) = A^T` if this flag is ``True``,", "type": "Args"}, "unitriangular": {"description": "whether :math:`A` is unit triangular.", "type": "Args"}}}, {"func_name": "tril", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "tril_indices", "ret_type": "Tensor", "signature": {"row": {"description": "number of rows in the 2-D matrix.", "type": "Args"}, "col": {"description": "number of columns in the 2-D matrix.", "type": "Args"}, "offset": {"description": "diagonal offset from the main diagonal.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "layout": {"description": "currently only support ``torch.strided``.", "type": "Keyword args"}}}, {"func_name": "triu", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "diagonal": {"description": "the diagonal to consider", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "triu_indices", "ret_type": "Tensor", "signature": {"row": {"description": "number of rows in the 2-D matrix.", "type": "Args"}, "col": {"description": "number of columns in the 2-D matrix.", "type": "Args"}, "offset": {"description": "diagonal offset from the main diagonal.", "type": "Args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "layout": {"description": "currently only support ``torch.strided``.", "type": "Keyword args"}}}, {"func_name": "trunc", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "unbind", "ret_type": "seq", "signature": {"input": {"description": "the tensor to unbind", "type": "Arguments"}, "dim": {"description": "dimension to remove", "type": "Arguments"}}}, {"func_name": "unflatten", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "Dimension to be unflattened, specified as an index into", "type": "Args"}}}, {"func_name": "unsqueeze", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the index at which to insert the singleton dimension", "type": "Args"}}}, {"func_name": "vander", "ret_type": "Tensor", "signature": {"x": {"description": "1-D input tensor.", "type": "Arguments"}, "N": {"description": "Number of columns in the output. If N is not specified,", "type": "Arguments"}, "increasing": {"description": "Order of the powers of the columns. If True,", "type": "Arguments"}}}, {"func_name": "var", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "var_mean", "ret_type": "(Tensor, Tensor)", "signature": {"input": {"description": "the input tensor.", "type": "Args"}, "dim": {"description": "the dimension or dimensions to reduce.", "type": "Args"}, "correction": {"description": "difference between the sample size and sample degrees of freedom.", "type": "Keyword args"}, "keepdim": {"description": "whether the output tensor has :attr:`dim` retained or not.", "type": "Keyword args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "vdot", "ret_type": "Tensor", "signature": {"input": {"description": "first tensor in the dot product, must be 1D. Its conjugate is used if it's complex.", "type": "Args"}, "other": {"description": "second tensor in the dot product, must be 1D.", "type": "Args"}, "..": {"description": "the output tensor.", "type": "Keyword args"}, ">>>": {"description": "0j))", "type": "Keyword args"}}}, {"func_name": "view_as_complex", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "view_as_real", "ret_type": "Tensor", "signature": {"input": {"description": "the input tensor.", "type": "Args"}}}, {"func_name": "vsplit", "ret_type": "List of Tensors", "signature": {"input": {"description": "tensor to split.", "type": "Args"}, "indices_or_sections": {"description": "See argument in :func:`torch.tensor_split`.", "type": "Args"}}}, {"func_name": "vstack", "ret_type": "Tensor", "signature": {"tensors": {"description": "sequence of tensors to concatenate", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "where", "ret_type": "Tensor", "signature": {"condition": {"description": "When True (nonzero), yield input, otherwise yield other", "type": "Arguments"}, "input": {"description": "value (if :attr:`input` is a scalar) or values selected at indices", "type": "Arguments"}, "other": {"description": "value (if :attr:`other` is a scalar) or values selected at indices", "type": "Arguments"}, "out": {"description": "the output tensor.", "type": "Keyword args"}}}, {"func_name": "zeros", "ret_type": "Tensor", "signature": {"size": {"description": "a sequence of integers defining the shape of the output tensor.", "type": "Args"}, "out": {"description": "the output tensor.", "type": "Keyword args"}, "dtype": {"description": "the desired data type of returned tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned Tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}}}, {"func_name": "zeros_like", "ret_type": "Tensor", "signature": {"input": {"description": "the size of :attr:`input` will determine size of the output tensor.", "type": "Args"}, "dtype": {"description": "the desired data type of returned Tensor.", "type": "Keyword args"}, "layout": {"description": "the desired layout of returned tensor.", "type": "Keyword args"}, "device": {"description": "the desired device of returned tensor.", "type": "Keyword args"}, "requires_grad": {"description": "If autograd should record operations on the", "type": "Keyword args"}, "memory_format": {"description": "the desired memory format of", "type": "Keyword args"}}}]